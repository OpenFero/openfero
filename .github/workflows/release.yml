# .github/workflows/release.yml
name: release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "New tag"
        required: true
  push:
    tags:
      - "[0-9]+.[0-9]+.[0-9]+*"

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for creating releases
      packages: write # Required for publishing container images
      pull-requests: write # Required for creating pull requests
      id-token: write # Required for OIDC token for Cosign
    env:
      NEW_VERSION: "0.0.0"
      IS_NIGHTLY: false
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Set up Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version-file: "go.mod"
          cache: false # Disable cache to prevent cache poisoning

      - name: Setup Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6.1.0
        with:
          node-version: "22"

      - name: Build Frontend
        working-directory: frontend
        run: |
          npm ci
          npm run build

      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Log into registry ${{ env.REGISTRY }}
        if: github.event_name != 'pull_request'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set GORELEASER_PREVIOUS_TAG in actual release
        run: |
          prev_tag=$(git tag -l | sed 's/^v//' | sort -V | grep -Ev "(nightly|latest)" | tail -n 1)
          echo "GORELEASER_PREVIOUS_TAG=$prev_tag" >> "$GITHUB_ENV"

      - name: Create tag (only for workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ github.event.inputs.tag }}
        run: git tag "$TAG"

      - name: Set pre-release flag for nightly builds
        id: set-prerelease
        env:
          INPUT_TAG: ${{ github.event.inputs.tag }}
          GITHUB_REF_NAME: ${{ github.ref }}
        run: |
          if [[ "$INPUT_TAG" =~ .*-nightly.* ]] || [[ "$GITHUB_REF_NAME" =~ .*-nightly.* ]]; then
            echo "IS_NIGHTLY=true" >> "$GITHUB_ENV"
          else
            echo "IS_NIGHTLY=false" >> "$GITHUB_ENV"
          fi

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@e435ccd777264be153ace6237001ef4d979d3a7a # v6.4.0
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_CURRENT_TAG: ${{ github.event.inputs.tag }}
          GORELEASER_PREVIOUS_TAG: ${{ env.GORELEASER_PREVIOUS_TAG }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0
        with:
          cosign-release: "v2.6.0"

      - name: Sign container images
        env:
          INPUT_TAG: ${{ github.event.inputs.tag }}
          GITHUB_REF_NAME: ${{ github.ref }}
        run: |
          echo "Signing container images with Cosign..."

          # Get image tag from environment or default
          IMAGE_TAG="$INPUT_TAG"
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG=$(echo "$GITHUB_REF_NAME" | sed 's/refs\/tags\///')
          fi

          # Sign the container image
          IMAGE_NAME="ghcr.io/openfero/openfero:${IMAGE_TAG}"
          echo "Signing image: ${IMAGE_NAME}"
          cosign sign --yes "${IMAGE_NAME}"

          # Sign latest tag if not a pre-release
          if [[ ! "$IMAGE_TAG" =~ .*-nightly.* ]]; then
            LATEST_IMAGE="ghcr.io/openfero/openfero:latest"
            echo "Signing latest tag: ${LATEST_IMAGE}"
            cosign sign --yes "${LATEST_IMAGE}"
          fi

          echo "Container images signed successfully"

          # Verify signatures
          echo "Verifying signature..."
          cosign verify "${IMAGE_NAME}" \
            --certificate-identity-regexp "https://github.com/OpenFero/openfero/.github/workflows/release.yml@.*" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" || echo "Verification completed (may show warnings for new signatures)"

      - name: Sign release artifacts
        if: ${{ !contains(github.ref, '-nightly') }}
        run: |
          echo "Signing release artifacts..."

          # Sign checksums file if it exists
          if [ -f "dist/checksums.txt" ]; then
            echo "Signing checksums.txt..."
            cosign sign-blob --yes \
              --output-signature=dist/checksums.txt.sig \
              --output-certificate=dist/checksums.txt.pem \
              dist/checksums.txt
            echo "Checksums signed"
          fi

          # Sign SBOM files if they exist
          for sbom in dist/*.sbom.json; do
            if [ -f "$sbom" ]; then
              echo "Signing SBOM: $(basename "$sbom")"
              cosign sign-blob --yes \
                --output-signature="${sbom}.sig" \
                --output-certificate="${sbom}.pem" \
                "$sbom"
            fi
          done

          echo "All artifacts signed successfully"

      - name: Package charts
        id: chart-releaser
        if: ${{ !contains(github.ref, '-nightly') }}
        env:
          INPUT_TAG: ${{ github.event.inputs.tag }}
        run: |
          # Get current version and calculate new patch version
          CURRENT_VERSION=$(grep '^version:' charts/openfero/Chart.yaml | awk '{print $2}')
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          echo "NEW_VERSION=$NEW_VERSION" >> "$GITHUB_ENV"

          # Update both version and appVersion
          sed -i "s/^version: .*/version: $NEW_VERSION/g" charts/openfero/Chart.yaml
          sed -i "s/^appVersion: .*/appVersion: ${INPUT_TAG}/g" charts/openfero/Chart.yaml

          helm package charts/* --destination .cr-release-packages

      - name: Push charts to GHCR
        id: push-charts
        if: ${{ !contains(github.ref, '-nightly') }}
        run: |
          shopt -s nullglob
          for pkg in .cr-release-packages/*; do
            if [ -z "${pkg:-}" ]; then
              break
            fi
            helm push "${pkg}" "oci://ghcr.io/openfero/openfero/charts"
          done

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@84ae59a2cdc2258d6fa0732dd66352dddae2a412 # v7.0.9
        if: ${{ !contains(github.ref, '-nightly') }}
        with:
          commit-message: Bump chart version to ${{ env.NEW_VERSION }}
          title: Bump chart version to ${{ env.NEW_VERSION }}
          body: |
            Updates the Helm chart version for release ${{ github.event.inputs.tag }}
          branch: bump-chart-${{ env.NEW_VERSION }}
          base: ${{ github.ref_name }}
          add-paths: charts/openfero/Chart.yaml
          delete-branch: true

      - name: Upload signatures to release
        if: ${{ !contains(github.ref, '-nightly') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
          GITHUB_REF_NAME: ${{ github.ref }}
        run: |
          # Get the release tag name
          TAG_NAME="$INPUT_TAG"
          if [ -z "$TAG_NAME" ]; then
            TAG_NAME=$(echo "$GITHUB_REF_NAME" | sed 's/refs\/tags\///')
          fi

          echo "Uploading signature files to release: $TAG_NAME"

          # Upload signature files if they exist
          for sig_file in dist/*.sig dist/*.pem; do
            if [ -f "$sig_file" ]; then
              echo "Uploading $(basename "$sig_file") to release..."
              gh release upload "$TAG_NAME" "$sig_file" --clobber || echo "Failed to upload $sig_file"
            fi
          done

          echo "Signature files uploaded to release"
